package no.ntnu.idata2900.project.esg_module_backend.sources;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import no.ntnu.idata2900.project.esg_module_backend.generators.DataPointGenerator;
import no.ntnu.idata2900.project.esg_module_backend.models.Trip;
import no.ntnu.idata2900.project.esg_module_backend.models.data_points.DataPoint;
import no.ntnu.idata2900.project.esg_module_backend.services.ModelService;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * The FakeDataSource class simulates a data source to produce boat-related data at intervals.
 * It implements the DataSource interface and sends generated ship data to a DataListener.
 * This class is primarily designed for testing or simulation purposes where no actual data source exists.
 *
 * @author Group 14
 * @version v0.2.2 (2025.05.13)
 */
@Component
public class FakeDataSource implements DataSource {
  private Logger logger = LoggerFactory.getLogger(FakeDataSource.class);
  private ScheduledExecutorService scheduler;
  private DataListener listener;
  private int i = 0;
  private List<DataPoint> clients; //Contains the last dp of each client.
  private final DataPointGenerator generator;
  private final ModelService modelService;

  @Autowired
  public FakeDataSource(DataPointGenerator generator, ModelService modelService) {
    this.generator = generator;
    this.modelService = modelService;
    this.clients = new ArrayList<>();
  }

  public void addClient(Trip trip) {
    logger.info("Adding client with ID: {}", trip.getId());
    clients.add(generator.generate(null, trip));
    logger.info("Printing client datapoints");
    clients.forEach(dp -> logger.info("Client data point: {}", dp));
  }

  public void restoreClients(List<DataPoint> clients) {
    logger.info("Restoring clients");
    this.clients = clients;
  }

  public void removeClient(Trip trip) {
    logger.info("Removing client with ID: {}", trip.getId());
    clients.removeIf(dp -> dp.getTrip().getId().equals(trip.getId()));
  }

  @Override
  public void start() {
    logger.debug("Starting FakeDataSource...");
    // Make sure any existing scheduler is shut down
    if (scheduler != null && !scheduler.isShutdown()) {
      scheduler.shutdownNow();
    }

    scheduler = Executors.newSingleThreadScheduledExecutor();

    scheduler.scheduleAtFixedRate(() -> {
      logger.debug("start of scheduled task");
      if (listener != null) {
        List<DataPoint> updatedClients = new ArrayList<>();
        for (DataPoint dp : clients) {
          logger.info("processing a client datapoint");
          DataPoint updatedDp = generator.generate(dp, dp.getTrip());
          DataPoint predictedDp = modelService.fetchTargetValues(updatedDp);
          updatedClients.add(predictedDp);
          logger.info("Client data point after update: {}", predictedDp);
          listener.onDataReceived(predictedDp);
        }
        clients = updatedClients;
      }
      i = (i + 1);
    }, 0, 15, TimeUnit.SECONDS);

    System.out.println("FakeDataSource started");
  }

  /**
   * Sets the data listener for this data source.
   * This listener will be notified whenever new data, such as a {@link DataPoint},
   * is generated by the fake data source. The assigned listener must implement
   * the {@link DataListener} interface, with its {@code onDataReceived} method
   * being invoked upon data updates.
   *
   * @param listener The {@link DataListener} instance to receive updated ship data.
   */
  @Override
  public void setDataListener(DataListener listener) {
    this.listener = listener;
    System.out.println("FakeDataSource sending data");
  }
}
