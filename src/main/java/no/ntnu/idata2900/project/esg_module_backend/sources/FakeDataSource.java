package no.ntnu.idata2900.project.esg_module_backend.sources;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import no.ntnu.idata2900.project.esg_module_backend.generators.DataPointGenerator;
import no.ntnu.idata2900.project.esg_module_backend.models.Trip;
import no.ntnu.idata2900.project.esg_module_backend.models.data_points.DataPoint;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * The FakeDataSource class simulates a data source to produce boat-related data at intervals.
 * It implements the DataSource interface and sends generated ship data to a DataListener.
 * This class is primarily designed for testing or simulation purposes where no actual data source exists.
 *
 * @author Group 14
 * @version v0.2.1 (2025.05.05)
 */
@Component
public class FakeDataSource implements DataSource {
  private Logger logger = LoggerFactory.getLogger(FakeDataSource.class);
  private ScheduledExecutorService scheduler;
  private DataListener listener;
  private int i = 0;
  private List<DataPoint> clients; //Contains the last dp of each client.
  private final DataPointGenerator generator;

  @Autowired
  public FakeDataSource(DataPointGenerator generator) {
    this.generator = generator;
    this.clients = new ArrayList<>();
  }

  public void addClient(Trip trip) {
    logger.info("Adding client with ID: {}", trip.getId());
    clients.add(generator.generate(null, trip));
    logger.info("Printing client datapoints");
    clients.forEach(dp -> logger.info("Client data point: {}", dp));
  }

  public void restoreClients(List<DataPoint> clients) {
    logger.info("Restoring clients");
    this.clients = clients;
  }

  public void removeClient(Trip trip) {
    logger.info("Removing client with ID: {}", trip.getId());
    clients.removeIf(dp -> dp.getTrip().getId().equals(trip.getId()));
  }

  @Override
  public void start() {
    logger.info("Starting FakeDataSource...");
    // Make sure any existing scheduler is shut down
    if (scheduler != null && !scheduler.isShutdown()) {
      scheduler.shutdownNow();
    }

    scheduler = Executors.newSingleThreadScheduledExecutor();

    scheduler.scheduleAtFixedRate(() -> {
      logger.info("start of scheduled task");
      if (i < 200) {
          if (listener != null) {
            List<DataPoint> updatedClients = new ArrayList<>();
            for (DataPoint dp : clients) {
              logger.info("processing a client datapoint");
              DataPoint updatedDp = generator.generate(dp, dp.getTrip());
              updatedClients.add(updatedDp);
              logger.info("Client data point after update: {}", updatedDp);
              listener.onDataReceived(updatedDp);
            }
            clients = updatedClients;
          }
          i = (i + 1);
      } else {
        stop();
      }
    }, 0, 15, TimeUnit.SECONDS);

    System.out.println("FakeDataSource started");
  }

  @Override
  public void stop() {
//    if (scheduler != null && !scheduler.isShutdown()) {
//      scheduler.shutdownNow();
//      scheduler = null;
//    }
//
//    i = 0;
//    System.out.println("FakeDataSource stopped");
  }


  /**
   * Sets the data listener for this data source.
   * This listener will be notified whenever new data, such as a {@link DataPoint},
   * is generated by the fake data source. The assigned listener must implement
   * the {@link DataListener} interface, with its {@code onDataReceived} method
   * being invoked upon data updates.
   *
   * @param listener The {@link DataListener} instance to receive updated ship data.
   */
  @Override
  public void setDataListener(DataListener listener) {
    this.listener = listener;
    System.out.println("FakeDataSource sending data");
  }
}
